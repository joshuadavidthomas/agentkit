/**
 * Skill Activation Guard Extension
 *
 * Strips skills from the system prompt when their declared path requirements
 * aren't met in the current project.
 *
 * Skills declare requirements via frontmatter metadata:
 *
 *   ---
 *   name: jj
 *   description: ...
 *   metadata:
 *     requires-path: ".jj/"
 *   ---
 *
 * The `requires-path` value is checked relative to the working directory.
 * Supports globs via simple prefix matching for directory patterns (trailing /).
 *
 * When the path doesn't exist, the skill's <skill> entry is removed from the
 * system prompt, so the LLM never sees it.
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { readFileSync, existsSync, readdirSync, statSync } from "node:fs";
import { join, resolve, basename, dirname } from "node:path";

interface SkillGuard {
	name: string;
	requiresPath: string;
}

/**
 * Parse YAML frontmatter from a markdown file.
 * Minimal parser — just extracts key: value pairs we care about.
 */
function parseFrontmatter(content: string): Record<string, unknown> {
	const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
	if (!match) return {};

	const yaml = match[1];
	const result: Record<string, unknown> = {};
	const metadata: Record<string, string> = {};
	let inMetadata = false;

	for (const line of yaml.split("\n")) {
		const trimmed = line.trimEnd();

		// Detect metadata block
		if (/^metadata:\s*$/.test(trimmed)) {
			inMetadata = true;
			continue;
		}

		// Inside metadata block — indented key: value
		if (inMetadata && /^\s+\S/.test(trimmed)) {
			const kv = trimmed.trim().match(/^([\w-]+):\s*(.+)/);
			if (kv) {
				metadata[kv[1]] = kv[2].replace(/^["']|["']$/g, "");
			}
			continue;
		}

		// If we were in metadata and hit a non-indented line, we're out
		if (inMetadata && /^\S/.test(trimmed)) {
			inMetadata = false;
		}

		// Top-level key: value
		const kv = trimmed.match(/^([\w-]+):\s*(.+)/);
		if (kv) {
			result[kv[1]] = kv[2].replace(/^["']|["']$/g, "");
		}
	}

	if (Object.keys(metadata).length > 0) {
		result.metadata = metadata;
	}

	return result;
}

/**
 * Scan a directory for skills with requires-path metadata.
 */
function scanSkillDir(dir: string): SkillGuard[] {
	const guards: SkillGuard[] = [];

	if (!existsSync(dir)) return guards;

	try {
		for (const entry of readdirSync(dir)) {
			const fullPath = join(dir, entry);
			let stat;
			try {
				stat = statSync(fullPath);
			} catch {
				continue;
			}

			if (!stat.isDirectory()) continue;

			const skillFile = join(fullPath, "SKILL.md");
			if (!existsSync(skillFile)) continue;

			try {
				const content = readFileSync(skillFile, "utf-8");
				const fm = parseFrontmatter(content);
				const name = (fm.name as string) || basename(fullPath);
				const metadata = fm.metadata as Record<string, string> | undefined;
				const requiresPath = metadata?.["requires-path"];

				if (requiresPath) {
					guards.push({ name, requiresPath });
				}
			} catch {
				// Skip unreadable skills
			}
		}
	} catch {
		// Skip unreadable directories
	}

	return guards;
}

/**
 * Remove a skill's <skill> block from the system prompt XML.
 */
function stripSkillFromPrompt(systemPrompt: string, skillName: string): string {
	// Match the full <skill>...</skill> block containing this skill name.
	// The XML is generated by pi with predictable formatting:
	//   <skill>
	//     <name>skill-name</name>
	//     <description>...</description>
	//     <location>...</location>
	//   </skill>
	const escaped = skillName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
	const pattern = new RegExp(
		`\\s*<skill>\\s*<name>${escaped}</name>[\\s\\S]*?</skill>`,
		"g"
	);
	return systemPrompt.replace(pattern, "");
}

export default function (pi: ExtensionAPI) {
	let guards: SkillGuard[] = [];

	// Scan skill directories on session start.
	// These match pi's default skill locations (see core/skills.ts loadSkills).
	pi.on("session_start", async (_event, ctx) => {
		const home = process.env.HOME || "";
		const skillDirs = [
			join(home, ".pi", "agent", "skills"),
			join(home, ".agents", "skills"),
			join(ctx.cwd, ".pi", "skills"),
		];

		guards = [];
		for (const dir of skillDirs) {
			guards.push(...scanSkillDir(dir));
		}

		// Deduplicate by name (first wins, matching pi's behavior)
		const seen = new Set<string>();
		guards = guards.filter((g) => {
			if (seen.has(g.name)) return false;
			seen.add(g.name);
			return true;
		});
	});

	// Strip skills from system prompt when path requirements aren't met
	pi.on("before_agent_start", async (event, ctx) => {
		if (guards.length === 0) return;

		let systemPrompt = event.systemPrompt;
		let stripped = 0;

		for (const guard of guards) {
			const fullPath = resolve(ctx.cwd, guard.requiresPath);
			if (!existsSync(fullPath)) {
				systemPrompt = stripSkillFromPrompt(systemPrompt, guard.name);
				stripped++;
			}
		}

		if (stripped > 0) {
			return { systemPrompt };
		}
	});
}
