/**
 * skill-requires-path
 *
 * Strips skills from the system prompt when their `requires-path`
 * frontmatter field doesn't exist in the current project.
 *
 *   ---
 *   name: jj
 *   requires-path: ".jj/"
 *   ---
 *
 * The value is checked relative to the working directory. When the
 * path doesn't exist, the skill's <skill> entry is removed from the
 * system prompt so the LLM never sees it.
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { readFileSync, existsSync, readdirSync, statSync } from "node:fs";
import { join, resolve, basename } from "node:path";

interface SkillGuard {
	name: string;
	requiresPath: string;
}

/**
 * Extract a field value from YAML frontmatter.
 * Handles quoted and unquoted values.
 */
function extractField(frontmatter: string, field: string): string | undefined {
	const pattern = new RegExp(`^${field}:\\s*(.+)`, "m");
	const match = frontmatter.match(pattern);
	if (!match) return undefined;
	return match[1].trim().replace(/^["']|["']$/g, "");
}

/**
 * Parse frontmatter block from markdown content.
 * Returns the raw YAML string between --- delimiters.
 */
function getFrontmatter(content: string): string | undefined {
	const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
	return match?.[1];
}

/**
 * Scan a skill directory for skills with requires-path.
 */
function scanSkillDir(dir: string): SkillGuard[] {
	const guards: SkillGuard[] = [];

	if (!existsSync(dir)) return guards;

	try {
		for (const entry of readdirSync(dir)) {
			const fullPath = join(dir, entry);

			try {
				if (!statSync(fullPath).isDirectory()) continue;
			} catch {
				continue;
			}

			const skillFile = join(fullPath, "SKILL.md");
			if (!existsSync(skillFile)) continue;

			try {
				const content = readFileSync(skillFile, "utf-8");
				const fm = getFrontmatter(content);
				if (!fm) continue;

				const requiresPath = extractField(fm, "requires-path");
				if (!requiresPath) continue;

				const name = extractField(fm, "name") || basename(fullPath);
				guards.push({ name, requiresPath });
			} catch {
				// Skip unreadable skills
			}
		}
	} catch {
		// Skip unreadable directories
	}

	return guards;
}

/**
 * Remove a skill's <skill> block from the system prompt XML.
 *
 * The XML is generated by pi with predictable formatting (see core/skills.ts):
 *   <skill>
 *     <name>skill-name</name>
 *     <description>...</description>
 *     <location>...</location>
 *   </skill>
 */
function stripSkillFromPrompt(systemPrompt: string, skillName: string): string {
	const escaped = skillName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
	const pattern = new RegExp(
		`\\s*<skill>\\s*<name>${escaped}</name>[\\s\\S]*?</skill>`,
		"g",
	);
	return systemPrompt.replace(pattern, "");
}

export default function (pi: ExtensionAPI) {
	let guards: SkillGuard[] = [];

	// Scan skill directories on session start.
	// These match pi's default skill locations (see core/skills.ts loadSkills).
	pi.on("session_start", async (_event, ctx) => {
		const home = process.env.HOME || "";
		const skillDirs = [
			join(home, ".pi", "agent", "skills"),
			join(home, ".agents", "skills"),
			join(ctx.cwd, ".pi", "skills"),
		];

		guards = [];
		for (const dir of skillDirs) {
			guards.push(...scanSkillDir(dir));
		}

		// Deduplicate by name (first wins, matching pi's behavior)
		const seen = new Set<string>();
		guards = guards.filter((g) => {
			if (seen.has(g.name)) return false;
			seen.add(g.name);
			return true;
		});
	});

	// Strip skills from system prompt when path requirements aren't met
	pi.on("before_agent_start", async (event, ctx) => {
		if (guards.length === 0) return;

		let systemPrompt = event.systemPrompt;
		let stripped = 0;

		for (const guard of guards) {
			const fullPath = resolve(ctx.cwd, guard.requiresPath);
			if (!existsSync(fullPath)) {
				systemPrompt = stripSkillFromPrompt(systemPrompt, guard.name);
				stripped++;
			}
		}

		if (stripped > 0) {
			return { systemPrompt };
		}
	});
}
